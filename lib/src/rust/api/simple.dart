// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.6.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `credentials`, `from_session`, `oauth`, `token`

String greet({required String name}) =>
    RustLib.instance.api.crateApiSimpleGreet(name: name);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<LibrespotPlayer>>
abstract class LibrespotPlayer implements RustOpaqueInterface {
  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<LibrespotPlayer> newInstance(
          {required String accessToken, required String trackId}) =>
      RustLib.instance.api.crateApiSimpleLibrespotPlayerNew(
          accessToken: accessToken, trackId: trackId);

  static Future<LibrespotPlayer> newWithLogin5(
          {required String id,
          required String password,
          required String trackId}) =>
      RustLib.instance.api.crateApiSimpleLibrespotPlayerNewWithLogin5(
          id: id, password: password, trackId: trackId);

  void pause();

  void play();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PkceOAuthSession>>
abstract class PkceOAuthSession implements RustOpaqueInterface {
  Future<String?> accessToken();

  OAuthAuthorizeUrl authUrl();

  Future<void> callback({required String code});

  static String clientIdRedirectUri({required String clientId}) => RustLib
      .instance.api
      .crateApiSimplePkceOAuthSessionClientIdRedirectUri(clientId: clientId);

  static PkceOAuthSession fromTokenJson({required String token}) =>
      RustLib.instance.api
          .crateApiSimplePkceOAuthSessionFromTokenJson(token: token);

  factory PkceOAuthSession() =>
      RustLib.instance.api.crateApiSimplePkceOAuthSessionNew();

  Future<String?> refreshToken();

  Future<String?> tokenJson();
}

class OAuthAuthorizeUrl {
  final String authUrl;
  final String redirectUrl;

  const OAuthAuthorizeUrl({
    required this.authUrl,
    required this.redirectUrl,
  });

  @override
  int get hashCode => authUrl.hashCode ^ redirectUrl.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OAuthAuthorizeUrl &&
          runtimeType == other.runtimeType &&
          authUrl == other.authUrl &&
          redirectUrl == other.redirectUrl;
}
